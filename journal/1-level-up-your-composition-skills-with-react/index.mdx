---
  title: "Level-up your composition skills with React: The Compound Component pattern"
  description: This article is a first step in a series that will dive deep into React composition patterns. In this article, we'll explore the Compound Component pattern and how it can help us build more flexible and scalable components.
  date: 04/03/2023
  imageSrc: /journal/1-react-context-composition.png
  imageAlt: Multiple components that work together with different shapes and colors sitting on top of a desk.
  imageCredit: "DALL-E 2: components composition, digital art"
  headers:
    Cache-Control: no-cache
---

> Note: {frontmatter.description}

We need to collectively acknowledge although its critical for building scalable components for applications, striking a good level of composition is a challenging feat, not only does it take a good time to think about the feature you want to build but it also requires you to reason about and predict the use-cases the component will have to meet in the future.

**Fortunately** for us, there are multiple patterns we can apply to increase the composability of our components. One that I really appreciate is the `Compound Component` pattern and its variations.

But before I dive into the details of this pattern and how it works, let's first understand the problem its trying to solve by following a task I was recently assigned to work on.

## The problem

While I was doing a consultation gig I was tasked on enhancing the _DX_ of this bloated map component that was becoming harder and harder to maintain. On top of that, it wasn't even handling all of their use-cases, so they had to repeat code in multiple views.

They had tried to fix the problem before by extracting out some UI elements into their own components, but adding more features to the map required you to mess around with this huge component that was handling a lot of unrelated logic and features.

To give you a better idea of what I'm talking about, here's a simplified version of the way you would go about using that component:

```javascript lines=2,5,6,9
<HugeMapComponent
  enableLayerX
  geojson={geojson}
  featureStatuses={featureStatuses}
  filterFnForLayerX={filterFnForLayerX}
  dataForLayerX={dataForLayerX}
  onSelectFeature={onSelectFeature}
  isMobileSelectionEnabled={isMobileSelectionEnabled}
  onEventXForLayerX={onEventXForLayerX}
  isFeatureEnabledZ={isFeatureEnabledZ}
  isFeatureEnabledW={isFeatureEnabledW}
  mapMode={mapMode}
  onEventXForLayerZ={onEventXForLayerZ}
  anotherProp={anotherProp}
  style={style}
  {...insert10MoreProps}
/>
```

And we even had one PR open to add new features changing the code above to:

```javascript add=2,6
<HugeMapComponent
  enableLayerX
  enableLayerY
  geojson={geojson}
  featureStatuses={featureStatuses}
  filterFnForLayerX={filterFnForLayerX}
  dataForLayerX={dataForLayerX}
  dataForLayerY={dataForLayerY}
  onSelectFeature={onSelectFeature}
  isMobileSelectionEnabled={isMobileSelectionEnabled}
  onEventXForLayerX={onEventXForLayerX}
  isFeatureEnabledZ={isFeatureEnabledZ}
  isFeatureEnabledW={isFeatureEnabledW}
  mapMode={mapMode}
  onEventXForLayerZ={onEventXForLayerZ}
  anotherProp={anotherProp}
  style={style}
  {...insert10MoreProps}
/>
```

When I find myself adding flags ‚òùÔ∏è to determine the behavior of a nested component I smell trouble. So I set myself to create the ultimate API for this component that would allow us to toggle layers (logic + template) of the component without adding more props and mixing unrelated logic.

Enter the `Compound Component` pattern.

## Compound Component

As a refresher on the `Compound Component` pattern, it basically lets you split out a component into extendable smaller components that you can compose however you need.

Take for example a component like this:

```javascript
<Menu buttonClassName="bg-blue-500 text-white" items={menuItems} />
```

If you're used to Tailwind's convention of using `className` and `className` alone, you know that you won't get Intellisense's auto-completion out of that `buttonClassName` prop.

It also doesn't allow you to customize the menu items. It's very rigid and any customization you want to do will require you to go through all the code in charge of _1) the button_, _2) the state logic_ and _3) rendering the list items_ when it could've been as simple as going straight to _#3_ and avoid introducing any bugs to the other elements ([separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns) is a good thing for a reason).

This is the years-old golden example of how you'd go about implementing the above component using the `Compound Component` pattern:

```javascript
<Menu>
  <MenuButton className="bg-blue-500 text-white">
    I toggle the collapsable menu! :){' '}
  </MenuButton>

  <MenuList>
    <MenuItem>Item 1</MenuItem>
    <MenuItem>Item 2</MenuItem>
    <MenuItem>Item 3</MenuItem>
  </MenuList>
</Menu>
```

The `Menu` component is the parent component that holds the state of the menu and passes it down to its children. The `MenuButton` and `MenuItem` consume the state and render accordingly. One obvious benefit of this is that it gives you **control** on _what_ pieces of the `Menu` to render and _where_ to render them.

You could, for example, skip the button alltogether and make it so firing an action toggles on the `Menu`:

```javascript add=2
<Menu>
  <LoginDialogWithMenuToggle />

  <MenuList>
    <MenuItem>Protected action 1</MenuItem>
    <MenuItem>Protected action 2</MenuItem>
    <MenuItem>Protected action 3</MenuItem>
  </MenuList>
</Menu>
```

It was as simple as changing that single line of code and we were able to extend the `Menu` component to support a new use-case.

But what is going on under the hood? How does the `LoginDialogWithMenuToggle` component know how to trigger the state?

The answer is the React.Children API and the `cloneElement` method. Here's how it might work (don't give the code too much thought):

```javascript lines=8,18
function Menu({ children }) {
  const [isOpen, setIsOpen] = React.useState(false)

  const toggleMenu = () => setIsOpen(!isOpen)

  const childrenWithProps = React.Children.map(children, (child) => {
    if (React.isValidElement(child)) {
      return React.cloneElement(child, { isOpen, toggleMenu })
    }

    return child
  })

  return <div>{childrenWithProps}</div>
}

function MenuList({ children, isOpen }) {
  return isOpen ? <div>{children}</div> : null
}
```

In this case, `Menu` is going through all of its **direct** children and cloning them to pass them down the `isOpen` and `toggleMenu` props.

This sounds great _initially_ but it leads you to write fragile code. To illustrate that, imagine you had to put a wrapper between `Menu` and `MenuList`:

```javascript add=4,10 filename=broken-component.jsx broken=true
<Menu>
  <MenuButton>Where is my list? :( </MenuButton>

  <div>
    <MenuList>
      <MenuItem>Item 1</MenuItem>
      <MenuItem>Item 2</MenuItem>
      <MenuItem>Item 3</MenuItem>
    </MenuList>
  </div>
</Menu>
```

Now the `Menu` component won't be able to pass down the props to the `MenuList` because it's not a **direct** child anymore. We have the entire functionality of `Menu` broken because it is tight to an implementation detail that it can't enforce.

To fix this, we need to be _flexible_ about _where_ we put the elements in the tree!

> Note: The `Compound Component` pattern as described here is not encouraged anymore [due to the API it uses are fragile](https://beta.reactjs.org/reference/react/Children) as shown above. Going forward you should only be using the `Flexible Compound Component` pattern we'll see now.

## Flexible Compound Component

This pattern works by enhancing the `Compound Component` pattern by using the React Context API to pass down the state to its children _anywhere in the tree_. To the developer implementing a Flexible Compound Component, it's <s>exactly like</s> very similar to the component we've seen so far:

```javascript filename=functional-component.jsx
<Menu>
  <MenuButton>I toggle the collapsable menu! :)</MenuButton>

  <div>
    <MenuList>
      <MenuItem>Item 1</MenuItem>
      <MenuItem>Item 2</MenuItem>
      <MenuItem>Item 3</MenuItem>
    </MenuList>
  </div>
</Menu>
```

But internally the `Menu` component is now exposing its state via React Context:

```javascript lines=1,7,14,22
const MenuContext = React.createContext()

function Menu({ children }) {
  const state = React.useState(false)

  return (
    <MenuContext.Provider value={state}>
      <div>{children}</div>
    </MenuContext.Provider>
  )
}

function MenuButton({ children }) {
  const [, setIsOpen] = React.useContext(MenuContext)

  const toggle = () => setIsOpen((isOpen) => !isOpen)

  return <button onClick={toggle}>{children}</button>
}

function MenuList({ children }) {
  const [isOpen] = React.useContext(MenuContext)
  return isOpen ? <div>{children}</div> : null
}
```

We can see that now, we're not limited to the direct children of `Menu` to consume the state. We can put the `MenuButton` anywhere in the tree and it will still be able to toggle the `Menu`.

## Conclusion

Overall this API is way more flexible üí™. The `Compound Component` pattern allowed us to compose our Menu component to fit our needs. We can also extend our Menu family of components in a variety of different ways. Got a new use-case? Just add a new component to the family and you're good to go!

We've just covered how the `Compound Component` pattern gives us the ability to extract and the `Flexible Compound Component` pattern gives us . But there's still plenty of room for improvement. Let's see how we can scale-up this API and optimize it for performance in the next article.
